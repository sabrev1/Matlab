Program 6: One Dimensional Heat Equation

(Implicit Method)

function [u]=heat_implicit ( to, tn,x0,xn, I, J,c)

h=(xn-x0) /I;

k=(tn-t0)/J

r=c*k/ (h) ^2;

f=@(x) 4*x-x^2 ;

x=x0:h:xn;

t=t0:k:tn;

u-zeros (I+1,J+1); u(:,1) f(x);

u (1,:)=0;

u (1+1, :)=0; A=diag ((1+2*r) *ones (1-1, 1)) -r*diag (ones (I- 2,1),-1)-diag (ones (1-2,1),1);

b-zeros (I-1,1);

for j=2:J+1

b(1,1) = u(2,j-1)+ru (1,3);

b (2:1-2,1)-u (3:1-1, j-1);

b(1-1,1)-u (I,j-1)+ru (I+1,j) u(2:1, j)-A\b;

end




. Euler’s Method 

 

MATLAB Code 

 

function []=Eulermethod(x0,y0,xn,h,f) x=x0:h:xn; n=length(x)-1; y(1)=y0; for i=1:n 

    y(i+1)=y(i)+h*f(x(i),y(i)); end 

fprintf('Approximate solution at x=%f is y=%f \n',xn,y(end)) plot(x,y,'*') hold on 

u=dsolve('Dy=y-x^2+1','y(0)=.5','x'); u=eval(u); 

fprintf('The solution obtained using dsolve at x=%f is u=%f \n',xn,u(end)) plot(x,u,'r') end  

Input: 

>> x0=0;y0=0.5;xn=1;h=0.25;  

>> f=@(x,y) y-x^2+1; >> Eulermethod(x0,y0,xn,h,f) 

Output: 

Approximate solution at x=1.000000 is y=2.418945  

The solution obtained using dsolve at x=1.000000 is u=2.640859 

 

3

 

 	2.5

 

2

 

 	1.5

 

1

 

 	0.50	0.1	0.2	0.3	0.4	0.5	0.6	0.7	0.8	0.9	1

 

 

2. Euler’s Modified Method 

MATLAB Code 

 

function []=Eulermod(x0,y0,xn,h,f) x=x0:h:xn; n=length(x)-1; y(1)=y0; for i=1:n 

    yp(i+1)=y(i)+h*f(x(i),y(i)); %predictor formula 

   y(i+1)=y(i)+h/2*(f(x(i),y(i))+f(x(i+1),yp(i+1))); % Corrector formula end 

fprintf('Approximate solution at x=%f is y=%f \n',xn,y(end)) plot(x,y,'*') hold on 

u=dsolve('Dy=y-x^2+1','y(0)=.5','x'); u=eval(u); 

fprintf('The solution obtained using dsolve at x=%f is u=%f \n',xn,u(end)) plot(x,u,'r') end  

Input: 

>> x0=0;y0=0.5;xn=1;h=0.25; 

>> f=@(x,y) y-x^2+1; >> Eulermod(x0,y0,xn,h,f) 

Output: 

Approximate solution at x=1.000000 is y=2.605493  

The solution obtained using dsolve at x=1.000000 is u=2.640859 

 

 

 

3. Runge-Kutta Fourth Order Method 

MATLAB Code 

 

function[ ]=RK4(x0,xn,y0,h,f) x=x0:h:xn; n=length(x)-1; y(1)=y0; for i=1:n     k1=f(x(i),y(i));     k2=f(x(i)+h/2,y(i)+h*k1/2);     k3=f(x(i)+h/2,y(i)+h*k2/2);     k4=f(x(i)+h,y(i)+h*k3); 

    y(i+1)=y(i)+(h/6)*(k1+2*k2+2*k3+k4); end 

fprintf('Approximate solution at x=%f is y=%f \n',xn,y(end)) plot(x,y,'*') hold on 

u=dsolve('Dy=y-x^2+1','y(0)=.5','x'); u=eval(u); 

fprintf('The solution obtained using dsolve at x=%f is u=%f \n',xn,u(end)) plot(x,u,'r') end  

Input: 

>> x0=0;y0=0.5;xn=1;h=0.25; 

>> f=@(x,y) y-x^2+1; >> RK4(x0,xn,y0,h,f) 

Output: 

Approximate solution at x=1.000000 is y=2.640772  

The solution obtained using dsolve at x=1.000000 is u=2.640859 

 

 

 

4. Milne’s Method 

MATLAB Code 

 

function []=MilnesMethod(x0,y0,xn,h,f) x=x0:h:xn; n=length(x)-1; y = zeros(1,n+1); y(1)=y0; for i=1:3 

    K1=f(x(i),y(i)); 

    K2=f(x(i)+h/2,y(i)+h*K1/2); 

    K3=f(x(i)+h/2,y(i)+h*K2/2);     K4=f(x(i)+h,y(i)+h*K3); 

    y(i+1)=y(i)+(h/6)*(K1+2*K2+2*K3+K4); end   

for i=4:n      

    y(i+1)=y(i-3)+(4*h/3)*(2*f(x(i),y(i))- f(x(i-1),y(i-1))+2*f(x(i-2),y(i-2))); 

%predictor formula 

    y(i+1)=y(i-1)+(h/3)*(f(x(i+1),y(i+1))+4*f(x(i),y(i))+f(x(i-1),y(i-1)));  

% Corrector formula end 

fprintf('Approximate solution at x=%f is y=%f \n',xn,y(end)) plot(x,y,'*') hold on 

u=dsolve('Dy=y-x^2+1','y(0)=.5','x'); u=eval(u); 

fprintf('The solution obtained using dsolve at x=%f is u=%f \n',xn,u(end)) plot(x,u,'r') end  

Input: 

>> x0=0;y0=0.5;xn=1;h=0.25; 

>> f=@(x,y) y-x^2+1; >> MilnesMethod(x0,y0,xn,h,f) 

Output: 

Approximate solution at x=1.000000 is y=2.640807 

The solution obtained using dsolve at x=1.000000 is u=2.640859 

 

 

 

 

 

 

 

 

 	 

 

 

 

Numerical solution of heat and wave equations  

5. Finite difference method to find numerical solution of Heat equation 

function [x,t,u] = FTCS(x0,xm,tn,h,k,c2,f) alpha=c2*k/h^2; if alpha >1/2 

    fprintf('The method fails') else x=x0:h:xm; m=length(x); t=0:k:tn; n=length(t); u=zeros(m,n); u(:,1)=f(x); for j=1:n-1     for i=2:m-1 

        u(i,j+1)= alpha*(u(i-1,j)+ u(i+1,j))+(1-2* alpha )*u(i,j);     end end surf(t,x,u) xlabel('t') ylabel('x') zlabel('u') end end  

 

Input: 

 

>> x0=0; xm = 8; tn = 0.5; h = 1; k=1/8; c2=4; 

>> f = @(x) 4*x -0.5*x.^2; 

>> [x,t,u] = FTCS(x0,xm,tn,h,k,c2,f) 

Output: 

x = 

     0     1     2     3     4     5     6     7     8 t = 

         0    0.1250    0.2500    0.3750    0.5000 u = 

         0         0         0         0         0 

    3.5000    3.0000    2.7500    2.5000    2.3125 

    6.0000    5.5000    5.0000    4.6250    4.2500 

    7.5000    7.0000    6.5000    6.0000    5.5625  

    8.0000    7.5000    7.0000    6.5000    6.0000 

    7.5000    7.0000    6.5000    6.0000    5.5625 

    6.0000    5.5000    5.0000    4.6250    4.2500 

    3.5000    3.0000    2.7500    2.5000    2.3125 

         0         0         0         0         0  

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

6. Numerical solution of Wave equation 

function [x,t,u] = CTCS_wave(t0,tn,x0,xm,h,k,c, f, g) r = c*k/h; if r>1 

    fprintf('The method fails\n');     return; end x=x0:h:xm; t=t0:k:tn; m=length(x); n=length(t); u=zeros(m,n); u(:,1)=f(x); for i=2:m-1 

    u(i,2)=(1-r^2)*u(i,1)+0.5*(r^2*(u(i-1,1)+u(i+1,1)))+k*g(x(i)); end for j=2:n-1     for i=2:m-1 

        u(i,j+1)=2*(1-r^2)*u(i,j)+r^2*(u(i-1,j)+u(i+1,j))-u(i,j-1);     end  end surf(t,x,u) end 

 Input: 

>> t0=0; tn=1; x0=0; xm=1; h=1/4; k=1/4; c=1; 

>> f= @(x) 0*x;  g = @(x) sin(pi*x); 

>> [x,t,u] = CTCS_wave(t0,tn,x0,xm,h,k,c, f, g) 

Output: 

x = 

         0    0.2500    0.5000    0.7500    1.0000 t = 

         0    0.2500    0.5000    0.7500    1.0000 u = 

         0         0         0         0         0 

         0    0.1768    0.2500    0.1768         0 

         0    0.2500    0.3536    0.2500         0 

         0    0.1768    0.2500    0.1768         0 

         0         0         0         0         0 

 

 

 

 

 

Built-in commands ode45, polyfit, and dsolve 

 



7. Solve the IVP 

	𝒚′′ − 𝟐𝒚′ + 𝒚 = −𝟐, 𝒚(𝟎) = 𝒚′(𝟎) = 𝟏 by using in-built command 

ode45	  	

 

f=@(t,y) [y(2);2*y(2)-y(1)-2]; y0=[1;1]; 

[ts,ys]=ode45(f,[0,1],y0); plot(ts,ys(:,1),'*','LineWidth',2) grid on 

 

Output: 

>> ode45builtin 

 ts = 

 

         0 

    0.0250     0.0500 

    0.0750 

    0.1000     0.1250     0.1500     0.1750     0.2000     0.2250     0.2500     0.2750     0.3000     0.3250     0.3500     0.3750     0.4000     0.4250     0.4500     0.4750     0.5000     0.5250     0.5500     0.5750     0.6000     0.6250     0.6500     0.6750     0.7000     0.7250     0.7500     0.7750     0.8000     0.8250     0.8500     0.8750     0.9000     0.9250     0.9500     0.9750 

    1.0000 

  ys = 

 

    1.0000    1.0000     1.0247    0.9740 

    1.0487    0.9461 

    1.0720    0.9162     1.0945    0.8841     1.1162    0.8499     1.1370    0.8133     1.1568    0.7743     1.1756    0.7328     1.1934    0.6888     1.2101    0.6420     1.2255    0.5924     1.2397    0.5399     1.2525    0.4844     1.2639    0.4257     1.2737    0.3637     1.2820    0.2984     1.2886    0.2294     1.2935    0.1568     1.2964    0.0804     1.2974   -0.0000     1.2964   -0.0845     1.2932   -0.1733     1.2877   -0.2666     1.2798   -0.3644     1.2694   -0.4671     1.2564   -0.5747     1.2407   -0.6874     1.2220   -0.8055     1.2003   -0.9291     1.1755   -1.0585     1.1474   -1.1938     1.1158   -1.3353     1.0805   -1.4832     1.0415   -1.6378     0.9986   -1.7992     0.9515   -1.9677     0.9001   -2.1436     0.8443   -2.3271     0.7837   -2.5186 

    0.7183   -2.7183 

 

 

8.1 Obtain the polynomial of degree one that fits the following data 

𝑥 = [1  2  3  4  5]     𝑦 = [1.1  2.3   5.6   6.9    7.5] 

 

x=[1 2 3 4 5]; y=[1.1 2.3 5.6 6.9 7.5]; p=polyfit(x,y,1); f=@(x) p(1)*x+p(2); plot(x,y,'*',x,f(x),'r') 

Output: 

>> polynomialfit p = 

    1.7400   -0.5400 

Therefore, the polynomial that fits the given data is 𝑓(𝑥) = 1.74𝑥 − 0.54 

 

 

8.2 Obtain the quadratic polynomial that fits the following data 

𝑥 = [1  2  3  4  5]     𝑦 = [1.1  2.3   5.6   6.9    7.5] 

x=[1 2 3 4 5]; y=[1.1 2.3 5.6 6.9 7.5]; p=polyfit(x,y,2) 

f=@(x) p(1)*x.^2+p(2)*x+p(3); plot(x,y,'*',x,f(x),'r')  

Output: 

>> polynomialfit p = 

   -0.2286    3.1114   -2.1400 

 

Therefore, the quadratic polynomial that fits the given data is 

𝑓(𝑥) = −0.2286𝑥2 + 3.1114𝑥 − 2.14 

 

 

9. Use built-in command dsolve to find the solution of the IVP 

	𝒅𝒚  = 𝒚 − 𝐬𝐢𝐧 𝒙 + 𝒙𝟐,	𝒚(𝟎) = 𝟏. 

𝒅𝒙

 

>> dsolve('Dy=y-sin(x)+x^2','y(0)=1','x') 

  ans =   

cos(x)/2 - 2*x + (5*exp(x))/2 + sin(x)/2 - x^

